
let width = 400
let height = 600

let view = create_sdl_view(width, height)
set_window_pos(view, 10, ())

struct colour {
  r, g, b, a
}

struct tetronimo {
  tiles, colour
}

fun set_draw_color(view, c : array) {
  set_draw_color(view, c[0], c[1], c[2], c[3])
}

let red = [255, 0, 50, 255]
let green = [0, 255, 0, 255]
let blue = [50, 100, 255, 255]
let sky_blue = [50, 200, 255, 255]
let orange = [255, 150, 50, 255]
let yellow = [255, 200, 0, 255]
let magenta = [255, 80, 255, 255]

let shape_l1 =
  [0, 1, 0, 0,
   0, 1, 0, 0,
   0, 1, 1, 0,
   0, 0, 0, 0,
  ]

let shape_l2 =
  [0, 0, 1, 0,
   0, 0, 1, 0,
   0, 1, 1, 0,
   0, 0, 0, 0,
  ]

let shape_bar =
  [ 0, 1, 0, 0,
    0, 1, 0, 0,
    0, 1, 0, 0,
    0, 1, 0, 0 ]

let shape_z =
  [ 0, 0, 0, 0,
    1, 1, 0, 0,
    0, 1, 1, 0,
    0, 0, 0, 0 ]

let shape_s =
  [ 0, 0, 0, 0,
    0, 0, 1, 1,
    0, 1, 1, 0,
    0, 0, 0, 0 ]

let shape_square =
  [ 0, 0, 0, 0,
    0, 1, 1, 0,
    0, 1, 1, 0,
    0, 0, 0, 0 ]

let shape_T =
  [ 0, 0, 0, 0,
    0, 1, 0, 0,
    1, 1, 1, 0,
    0, 0, 0, 0 ]

let colours = [
  shape_l1, orange,
  shape_l2, blue,
  shape_bar, sky_blue,
  shape_z, red,
  shape_s, green,
  shape_square, yellow,
  shape_T, magenta,
]

let r90 =
  [ 12,  8,  4,  0,
    13,  9,  5,  1,
    14,  10, 6,  2,
    15,  11, 7,  3 ]

fun rotate(shape, rotation_grid){
  let s = []
  for i in range(0, 16) {
    let index = rotation_grid[i]
    add(s, shape[index])
  }
  s
}

let tetronimos = {
  let ts = []
  for i in range(0, len(colours)/2) {
    let c = colours[i*2 + 1]
    let s1 = colours[i*2]
    let s2 = rotate(s1, r90)
    let s3 = rotate(s2, r90)
    let s4 = rotate(s3, r90)
    let t = tetronimo(tiles: [s1, s2, s3, s4], colour: c)
    add(ts, t)
  }
  ts
}

fun draw_tetronimo(
  view, shape, colour, size,
  xpos, ypos, xoffset, yoffset)
{
  set_draw_color(view, colour)
  for y in range(0, 4) {
    for x in range(0, 4) {
      let v = shape[x + y * 4]
      if v == 1 {
        fill_rect(
          view,
          size * (x + xpos) + xoffset,
          size * (y + ypos) + yoffset,
          size, size)
      }
    }    
  }
}

fun check_contact(grid, grid_width, grid_height, shape, pos_x, pos_y){
  for y in range(0, 4) {
    for x in range(0, 4) {
      if shape[x + y * 4] == 1 {
        let xpos = x + pos_x
        let ypos = y + pos_y
        if xpos < 0 || xpos >= grid_width {
          return true
        }
        if ypos >= grid_height {
          return true
        }
        let i = xpos + ypos * grid_width
        if grid[i] != () {
          return true
        }
      }
    }
  }
  return false
}

fun draw_all_shapes(){
  for i in range(0, len(all_shapes)) {
    for j in range(0, 4) {
      let s = all_shapes[i]
      draw_tetronimo(
        view, s.tiles[j], s.colour,
        20, 1 + j * 4, 1 + i * 5)
    }
  }
}

fun draw_background_grid(view, width, height, gap){
  for x in range(0, width/gap) {
    draw_line(view, x * gap, 0, x * gap, height)
  }
  for y in range(0, height/gap) {
    draw_line(view, 0, y * gap, width, y * gap)
  }
}

struct game {
  orientation,
  tet_index, 
  pos_x,
  pos_y,
  ticks_per_drop,
  tick_count,
  grid,
  tetronimos,
  tetronimo_bag,
  rng,
}

let tile_size = 25;
let rx = 40;
let ry = 40;
let grid_height = 20;
let grid_width = 10;

let grid = []
for i in range(0, grid_width * grid_height) {
  add(grid, ())
}

let game =
  game(
    orientation: 0,
    tet_index: 0,
    pos_x: grid_width/2 - 2,
    pos_y: 0,
    ticks_per_drop: 120,
    tick_count: 0,
    grid: grid,
    tetronimos: tetronimos,
    tetronimo_bag: [],
    rng: random_generator(),
  )

fun next_tetronimo(game){
  if len(game.tetronimo_bag) == 0 {
    for i in range(0, 2) {
      for i in range(0, len(game.tetronimos)) {
        add(game.tetronimo_bag, i)
      }
    }
  }
  let tets = len(game.tetronimo_bag)
  let i = next_rand(game.rng) * tets
  let next_tet = game.tetronimo_bag[i]
  game.tetronimo_bag[i] = game.tetronimo_bag[tets-1]
  pop(game.tetronimo_bag)
  next_tet
}

game.tet_index = next_tetronimo(game)

fun blit(game, shape, colour, grid_width) {
  for y in range(0, 4) {
    for x in range(0, 4) {
      if shape[x + y * 4] == 1 {
        let xpos = x + game.pos_x
        let ypos = y + game.pos_y
        let i = xpos + ypos * grid_width
        game.grid[i] = colour
      }
    }
  }
}

fun check_line(grid, y, grid_width) {
  let i = y * grid_width
  for i in range(i, i + grid_width) {
    if grid[i] == () {
      return false
    }
  }
  return true
}

fun min(a, b) {
  if a < b { a} else { b }
}

fun max(a, b) {
  if a > b { a} else { b }
}


fun erase_lines(grid, y, grid_width, grid_height) {
  for y in range(y, min(y + 4, grid_height)) {
    if check_line(grid, y, grid_width) {
      let end = (y + 1) * grid_width
      for i in range(1, (end + 1) - grid_width) {
        grid[end - i] = grid[(end - i) - grid_width]
      }
      for i in range(0, grid_width) {
        grid[i] = ()
      }
    }
  }
}

fun move_horizontal(game, grid_width, grid_height, shape, offset) {
  let new_x = game.pos_x + offset
  let c = check_contact(
    game.grid, grid_width, grid_height,
    shape, new_x, game.pos_y)
  if !c {
    game.pos_x = new_x
  }
}

fun move_down(game, shape, colour, grid_width, grid_height) {
  let new_y = game.pos_y + 1
  game.tick_count = 0
  let c = check_contact(
    game.grid, grid_width, grid_height,
    shape, game.pos_x, new_y)
  if c {
    blit(game, shape, colour, grid_width)
    erase_lines(game.grid, game.pos_y, grid_width, grid_height)
    game.pos_x = grid_width/2 - 2
    game.pos_y = 0
    game.tick_count = 0
    game.orientation = 0
    game.tet_index = next_tetronimo(game)
    true
  }
  else {
    game.pos_y = new_y
    false
  }
}

while true {

  let time = time_now()

  while true {
    let e = poll_event(view)
    if e == () {
      break
    }
    else {
      let tet = tetronimos[game.tet_index]
      let shape = tet.tiles[game.orientation]
      let t = type_name(e)
      if t == "sdl_event_quit" {
        return
      }
      if t == "sdl_event_keydown" {
        if e.key == "Escape" {
          return
        }
        if e.key == "Up" {
          game.orientation =
            (game.orientation + 1) % 4
        }
        if e.key == "Left" {
          move_horizontal(
            game, grid_width, grid_height, shape, -1)
        }
        if e.key == "Right" {
          move_horizontal(
            game, grid_width, grid_height, shape, 1)
        }
        if e.key == "Down" {
          move_down(game, shape, tet.colour, grid_width, grid_height)
        }
        if e.key == "Space" {
          while true {
            if move_down(game, shape, tet.colour, grid_width, grid_height) {
              break
            }
          }
        }
      }
    }
  }

  set_draw_color(view, 40, 40, 40, 255)
  clear(view)
  set_draw_color(view, 120, 120, 120, 255)
  draw_rect(view, rx, ry,
    tile_size * grid_width,
    tile_size * grid_height)

  let tet = tetronimos[game.tet_index]
  let shape = tet.tiles[game.orientation]

  game.tick_count = game.tick_count + 1
  if game.tick_count >= game.ticks_per_drop {
    move_down(game, shape, tet.colour, grid_width, grid_height)
  }

  for y in range(0, grid_height) {
    for x in range(0, grid_width) {
      let i = y * grid_width + x
      let c = game.grid[i]
      if c != () {
        set_draw_color(view, c)
        fill_rect(
          view,
          tile_size * x + rx,
          tile_size * y + ry,
          tile_size, tile_size)
      }
    }
  }

  let ghost_y = game.pos_y
  while true {
    let new_y = ghost_y + 1
    let c = check_contact(
      game.grid, grid_width, grid_height,
      shape, game.pos_x, new_y)
    if c {
      break
    }
    ghost_y = new_y
  }

  // draw ghost
  draw_tetronimo(
    view, shape, [60, 60, 60, 255],
    tile_size, game.pos_x, ghost_y,
    rx, ry)

  // draw real tetronimo
  draw_tetronimo(
    view, shape, tet.colour,
    tile_size, game.pos_x, game.pos_y,
    rx, ry)

  present(view)

  let elapsed = time_since(time)
  let millis = 1000/60
  let sleep_time = max(millis - elapsed, 0)

  //print(elapsed)

  sleep(sleep_time)
}
