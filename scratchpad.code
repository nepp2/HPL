
let width = 700
let height = 600

let view = create_sdl_view(width, height)
set_window_pos(view, 10, ())

struct colour {
  r, g, b, a
}

struct shape {
  tiles, colour
}

fun set_draw_color(view, c : array) {
  set_draw_color(view, c[0], c[1], c[2], c[3])
}

let red = [255, 0, 50, 255]
let green = [0, 255, 0, 255]
let blue = [50, 100, 255, 255]
let sky_blue = [50, 200, 255, 255]
let orange = [255, 150, 50, 255]
let yellow = [255, 200, 0, 255]
let magenta = [255, 80, 255, 255]

let shape_l1 =
  [0, 1, 0, 0,
   0, 1, 0, 0,
   0, 1, 1, 0,
   0, 0, 0, 0,
  ]

let shape_l2 =
  [0, 0, 1, 0,
   0, 0, 1, 0,
   0, 1, 1, 0,
   0, 0, 0, 0,
  ]

let shape_bar =
  [ 0, 1, 0, 0,
    0, 1, 0, 0,
    0, 1, 0, 0,
    0, 1, 0, 0 ]

let shape_z =
  [ 0, 0, 0, 0,
    1, 1, 0, 0,
    0, 1, 1, 0,
    0, 0, 0, 0 ]

let shape_s =
  [ 0, 0, 0, 0,
    0, 0, 1, 1,
    0, 1, 1, 0,
    0, 0, 0, 0 ]

let shape_square =
  [ 0, 0, 0, 0,
    0, 1, 1, 0,
    0, 1, 1, 0,
    0, 0, 0, 0 ]

let shape_T =
  [ 0, 0, 0, 0,
    0, 1, 0, 0,
    1, 1, 1, 0,
    0, 0, 0, 0 ]

let shapes = [
  shape_l1, orange,
  shape_l2, blue,
  shape_bar, sky_blue,
  shape_z, red,
  shape_s, green,
  shape_square, yellow,
  shape_T, magenta,
]

let r90 =
  [ 12,  8,  4,  0,
    13,  9,  5,  1,
    14,  10, 6,  2,
    15,  11, 7,  3 ]

fun rotate(shape, rotation_grid){
  let s = []
  for i in range(0, 16) {
    let index = rotation_grid[i]
    add(s, shape[index])
  }
  s
}

let all_shapes = {
  let all = []
  for i in range(0, len(shapes)/2) {
    let c = shapes[i*2 + 1]
    let s1 = shapes[i*2]
    let s2 = rotate(s1, r90)
    let s3 = rotate(s2, r90)
    let s4 = rotate(s3, r90)
    let shape = shape(tiles: [s1, s2, s3, s4], colour: c)
    add(all, shape)
  }
  all
}

fun draw_tetronimo(
  view, shape, colour, size,
  xpos, ypos, xoffset, yoffset)
{
  set_draw_color(view, colour)
  for y in range(0, 4) {
    for x in range(0, 4) {
      let v = shape[x + y * 4]
      if v == 1 {
        fill_rect(
          view,
          size * (x + xpos) + xoffset,
          size * (y + ypos) + yoffset,
          size, size)
      }
    }    
  }
}

fun check_contact(grid_width, shape, xpos){
  for y in range(0, 4) {
    for x in range(0, 4) {
      if shape[x + y * 4] == 1 {
        if xpos + x < 0 || xpos + x + 4 >= grid_width {
          return true
        }
      }
    }
  }
  return false
}

fun draw_all_shapes(){
  for i in range(0, len(all_shapes)) {
    for j in range(0, 4) {
      let s = all_shapes[i]
      draw_tetronimo(
        view, s.tiles[j], s.colour,
        20, 1 + j * 4, 1 + i * 5)
    }
  }
}

fun draw_background_grid(view, width, height, gap){
  for x in range(0, width/gap) {
    draw_line(view, x * gap, 0, x * gap, height)
  }
  for y in range(0, height/gap) {
    draw_line(view, 0, y * gap, width, y * gap)
  }
}

struct game {
  orientation,
  shape, 
  pos_x,
  pos_y,
}

let tile_size = 25;
let rx = 40;
let ry = 40;
let grid_height = 20;
let grid_width = 10;

let game =
  game(
    orientation: 0,
    shape: 0,
    pos_x: 0,
    pos_y: 0,
  )

while true {
  let e = poll_event(view)
  if e != () {
    let t = type_name(e)
    if t == "sdl_event_quit" {
      break
    }
    if t == "sdl_event_keydown" {
      if e.key == "Escape" {
        break
      }
      if e.key == "Up" {
        game.orientation =
          (game.orientation + 1) % 4
      }
      if e.key == "Left" {
        game.pos_x = game.pos_x - 1
      }
      if e.key == "Right" {
        game.pos_x = game.pos_x + 1
      }
      if e.key == "Down" {
        game.pos_y = game.pos_y + 1
      }
      if e.key == "Left Shift" {
        game.orientation = 0
        game.shape =
          (game.shape + 1) % len(all_shapes)
      }
    }
  }
  else {
    set_draw_color(view, 40, 40, 40, 255)
    clear(view)
    set_draw_color(view, 120, 120, 120, 255)
    draw_rect(view, rx, ry,
      tile_size * grid_width,
      tile_size * grid_height)

    let s = all_shapes[game.shape]
    let t = s.tiles[game.orientation];
    let c =
      if check_contact(grid_width, t, game.pos_x) {
        red
      }
      else {
        s.colour
      }
    draw_tetronimo(
      view, t, c,
      tile_size, game.pos_x, game.pos_y,
      rx, ry)

    present(view)
  }

  sleep(1000/60)
}
