// This code is partially translated to newer syntax, and doesn't work.

struct color {
  r : i64
  g : i64
  b : i64
  a : i64
}

struct tetronimo {
  tiles : array(array(i64))
  color : color
}

struct view {
  handle : sdl_window_handle
}

struct grid {
  cells : array(option(color))
}

struct palette {
  red: color
  green: color
  blue: color
  sky_blue: color
  orange: color
  yellow: color
  magenta: color
}

struct game {
  config: config
  orientation: i64
  tet_index: i64
  pos_x: i64
  pos_y: i64
  ticks_per_drop: i64
  tick_count: i64
  grid: grid
  tetronimos: array(tetronimo)
  tetronimo_bag: array(tetronimo)
  rng: rng_handle
  palette: palette
}

struct config {
  tile_size : i64
  rx : i64
  ry : i64
  grid_height : i64
  grid_width : i64      
}

fun set_draw_color(view : view, r : i64, g : i64, b : i64, a : i64) {
  view.handle.sdl_set_draw_color(r as u8, g as u8, b as u8, a as u8)
}

fun fill_rect(view : view, x : i64, y : i64, w : i64, h : i64) {
  let r = sdl_rect.new(x, y, w, h)
  view.handle.sdl_fill_rect(&r)
}

fun set_color(view : view, c : array(i64)) {
  view.set_draw_color(c[0], c[1], c[2], c[3])
}

fun next_tetronimo(game : game, grid_width : i64){
  if game.tetronimo_bag.len() == 0 {
    for i in range(0, 2) {
      for i in range(0, len(game.tetronimos)) {
        game.tetronimo_bag.add(i)
      }
    }
  }
  let tets = game.tetronimo_bag.len()
  let i = (game.rng.next_f64() * (tets as f64)) as i64
  let next_tet = game.tetronimo_bag[i]
  game.tetronimo_bag[i] = game.tetronimo_bag[tets-1]
  game.tetronimo_bag.pop()
  game.tet_index = next_tet
  game.init_tetronimo_state(grid_width)
}

fun shape_size(shape){
  sqrt(shape.len() as f64) as i64
}

fun rotate_90(shape){
  let size = shape_size(shape)
  let s = []
  for i in range(0, size * size) {
    let y = i / size
    let x = i % size
    let i = (size - 1 - x) * size + y
    s.add(shape[i])
  }
  s
}

fun init(view : view, width : i64, height : i64) {
  let shape_l1 =
    [ 0, 1, 0,
      0, 1, 0,
      0, 1, 1 ]

  let shape_l2 =
    [ 0, 1, 0,
      0, 1, 0,
      1, 1, 0 ]

  let shape_bar =
    [ 0, 1, 0, 0,
      0, 1, 0, 0,
      0, 1, 0, 0,
      0, 1, 0, 0 ]

  let shape_z =
    [ 0, 0, 0,
      1, 1, 0,
      0, 1, 1 ]

  let shape_s =
    [ 0, 0, 0,
      0, 1, 1,
      1, 1, 0 ]

  let shape_square =
    [ 1, 1,
      1, 1 ]

  let shape_T =
    [ 0, 1, 0,
      1, 1, 1,
      0, 0, 0 ]

  let p = palette.new(
    red: color.new(255, 0, 50, 255),
    green: color.new(0, 255, 0, 255),
    blue: color.new(50, 100, 255, 255),
    sky_blue: color.new(50, 200, 255, 255),
    orange: color.new(255, 150, 50, 255),
    yellow: color.new(255, 200, 0, 255),
    magenta: color.new(255, 80, 255, 255),
  )

  let shape_color_pairs = [
    tup(shape_l1, p.orange),
    tup(shape_l2, p.blue),
    tup(shape_bar, p.sky_blue),
    tup(shape_z, p.red),
    tup(shape_s, p.green),
    tup(shape_square, p.yellow),
    tup(shape_T, p.magenta),
  ]

  let tetronimos = {
    let ts = []
    for i in range(0, shape_color_pairs.len()) {
      let pair = shape_color_pairs[i]
      let c = pair.v1
      let s1 = pair.v0
      let s2 = s1.rotate_90()
      let s3 = s2.rotate_90()
      let s4 = s3.rotate_90()
      let t = tetronimo.new(
        tiles: [s1, s2, s3, s4],
        color: c)
      ts.add(t)
    }
    ts
  }

  let config = config.new(
    tile_size: 25,
    rx: 40,
    ry: 40,
    grid_height: 20,
    grid_width: 10,       
  )

  let grid = []
  for i in range(0, config.grid_width * config.grid_height) {
    grid.add(none())
  }
  let game =
    game.new(
      config: config,
      orientation: 0,
      tet_index: 0,
      pos_x: 0,
      pos_y: 0,
      ticks_per_drop: 200,
      tick_count: 0,
      grid,
      tetronimos: tetronimos,
      tetronimo_bag: [],
      rng: rng_handle(),
      palette: p,
    )
  game.next_tetronimo(config.grid_width)

  game
}

fun draw_tetronimo(
  view : view, shape : array(i64), color : color, size : i64,
  xpos : i64, ypos : i64, xoffset : i64, yoffset : i64)
{
  view.set_color(color)
  let shape_size = shape.shape_size()
  for y in range(0, shape_size) {
    for x in range(0, shape_size) {
      let v = shape[x + y * shape_size]
      if v == 1 {
        view.fill_rect(
          size * (x + xpos) + xoffset,
          size * (y + ypos) + yoffset,
          size, size)
      }
    }    
  }
}

static CONTACT_NONE = 0
static CONTACT_LEFT = 1
static CONTACT_RIGHT = 2
static CONTACT_BOTTOM = 3
static CONTACT_TOP = 4
static CONTACT_OVERLAP = 5

fun contact_type(grid : grid, grid_width : i64, grid_height : i64, shape : array(i64), pos_x : i64, pos_y : i64){
  let shape_size = shape.shape_size()
  for y in range(0, shape_size) {
    for x in range(0, shape_size) {
      if shape[x + y * shape_size] == 1 {
        let xpos = x + pos_x
        let ypos = y + pos_y
        if xpos < 0 {
          return CONTACT_LEFT
        }
        if xpos >= grid_width {
          return CONTACT_RIGHT
        }
        if ypos >= grid_height {
          return CONTACT_BOTTOM
        }
        if ypos >= 0 {
          let i = xpos + ypos * grid_width
          if grid[i] != () {
            return CONTACT_OVERLAP
          }
        }
      }
    }
  }
  return CONTACT_NONE
}

fun check_contact(grid : array(color), grid_width : i64, grid_height : i64, shape : array(i64), pos_x : i64, pos_y : i64){
  let c = contact_type( grid, grid_width, grid_height, shape, pos_x, pos_y)
  c != CONTACT_NONE
}

fun draw_all_shapes(){
  for i in range(0, len(all_shapes)) {
    for j in range(0, 4) {
      let s = all_shapes[i]
      draw_tetronimo(
        view, s.tiles[j], s.color,
        20, 1 + j * 4, 1 + i * 5)
    }
  }
}

fun draw_background_grid(view, width, height, gap){
  for x in range(0, width/gap) {
    draw_line(view, x * gap, 0, x * gap, height)
  }
  for y in range(0, height/gap) {
    draw_line(view, 0, y * gap, width, y * gap)
  }
}

fun init_tetronimo_state(game, grid_width) {
  game.pos_y = 0
  game.tick_count = 0
  game.orientation = 0
  let tet = game.tetronimos[game.tet_index]
  let shape = tet.tiles[game.orientation]
  let half_size = floor(shape_size(shape) / 2)
  game.pos_x = grid_width/2 - half_size
}

fun blit(game, shape, color, grid_width) {
  let shape_size = shape_size(shape)
  for y in range(0, shape_size) {
    for x in range(0, shape_size) {
      if shape[x + y * shape_size] == 1 {
        let xpos = x + game.pos_x
        let ypos = y + game.pos_y
        let i = xpos + ypos * grid_width
        game.grid[i] = color
      }
    }
  }
}

fun min(a, b) {
  if a < b { a} else { b }
}

fun max(a, b) {
  if a > b { a} else { b }
}

fun check_line(grid, y, grid_width) {
  let i = y * grid_width
  for i in range(i, i + grid_width) {
    if grid[i] == () {
      return false
    }
  }
  return true
}

fun erase_lines(grid, y, shape_size, grid_width, grid_height) {
  for y in range(y, min(y + shape_size, grid_height)) {
    if check_line(grid, y, grid_width) {
      let end = (y + 1) * grid_width
      for i in range(1, (end + 1) - grid_width) {
        grid[end - i] = grid[(end - i) - grid_width]
      }
      for i in range(0, grid_width) {
        grid[i] = ()
      }
    }
  }
}

fun move_horizontal(game, grid_width, grid_height, shape, offset) {
  let new_x = game.pos_x + offset
  let c = check_contact(
    game.grid, grid_width, grid_height,
    shape, new_x, game.pos_y)
  if !c {
    game.pos_x = new_x
  }
}

fun move_down(game, shape, color, grid_width, grid_height) {
  let new_y = game.pos_y + 1
  game.tick_count = 0
  let c = check_contact(
    game.grid, grid_width, grid_height,
    shape, game.pos_x, new_y)
  if c {
    blit(game, shape, color, grid_width)
    erase_lines(
      game.grid, game.pos_y, shape_size(shape),
      grid_width, grid_height)
    game.pos_x = grid_width/2 - 2
    game.pos_y = 0
    game.tick_count = 0
    game.orientation = 0
    next_tetronimo(game, grid_width)
    true
  }
  else {
    game.pos_y = new_y
    false
  }
}

fun rotate(game, grid_width, grid_height) {
  game.orientation = (game.orientation + 1) % 4
  let tet = game.tetronimos[game.tet_index]
  let shape = tet.tiles[game.orientation]
  while true {
    let c = contact_type(
      game.grid, grid_width, grid_height,
      shape, game.pos_x, game.pos_y)
    if c == () {
      break
    }
    else if c == CONTACT_LEFT {
      game.pos_x = game.pos_x + 1
    }
    else if c == CONTACT_RIGHT {
      game.pos_x = game.pos_x - 1
    }
    else {
      // overlap or bottom
      game.pos_y = game.pos_y - 1
    }
  }
}

fun update_tick(game) {
  let tet = tetronimos[game.tet_index]
  let shape = tet.tiles[game.orientation]

  game.tick_count = game.tick_count + 1
  if game.tick_count >= game.ticks_per_drop {
    move_down(game, shape, tet.color, grid_width, grid_height)
  }
}

fun update(game, e) {
  let tet = game.tetronimos[game.tet_index]
  let shape = tet.tiles[game.orientation]
  let c = game.config
  let grid_width = c.grid_width
  let grid_height = c.grid_height
  let t = type_name(e)
  if t == "sdl_event_keydown" {
    if e.key == "Up" {
      rotate(game, grid_width, grid_height)
    }
    if e.key == "Left" {
      move_horizontal(
        game, grid_width, grid_height, shape, -1)
    }
    if e.key == "Right" {
      move_horizontal(
        game, grid_width, grid_height, shape, 1)
    }
    if e.key == "Down" {
      move_down(game, shape, tet.color, grid_width, grid_height)
    }
    if e.key == "Space" {
      while true {
        if move_down(game, shape, tet.color, grid_width, grid_height) {
          break
        }
      }
    }
  }
  else if t == "tick" {
    game.tick_count = game.tick_count + 1
    if game.tick_count >= game.ticks_per_drop {
      move_down(game, shape, tet.color, grid_width, grid_height)
    }
  }
}

fun render(view, game) {
  set_draw_color(view, 40, 40, 40, 255)
  clear(view)
  set_draw_color(view, 120, 120, 120, 255)
  let c = game.config
  let rx = c.rx
  let ry = c.ry
  let tile_size = c.tile_size
  let grid_width = c.grid_width
  let grid_height = c.grid_height
  draw_rect(view, rx, ry,
    tile_size * grid_width,
    tile_size * grid_height)

  let tet = game.tetronimos[game.tet_index]
  let shape = tet.tiles[game.orientation]

  for y in range(0, grid_height) {
    for x in range(0, grid_width) {
      let i = y * grid_width + x
      let color = game.grid[i]
      if color != () {
        set_color(view, color)
        fill_rect(
          view,
          tile_size * x + rx,
          tile_size * y + ry,
          tile_size, tile_size)
      }
    }
  }

  let ghost_y = game.pos_y
  while true {
    let new_y = ghost_y + 1
    let c = check_contact(
      game.grid, grid_width, grid_height,
      shape, game.pos_x, new_y)
    if c {
      break
    }
    ghost_y = new_y
  }

  // draw ghost
  draw_tetronimo(
    view, shape, [60, 60, 60, 255],
    tile_size, game.pos_x, ghost_y,
    rx, ry)

  // draw real tetronimo
  draw_tetronimo(
    view, shape, tet.color,
    tile_size, game.pos_x, game.pos_y,
    rx, ry)

  present(view)
}
