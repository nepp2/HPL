
fun alloc(v : T) => T with T {
  let p = malloc(sizeof(T)) as ptr(T)
  *p = v
  p
}

struct inner_list(T) {
  len : u64
  data : ptr(T)
  capacity : u64
}

struct list(T) {
  p : ptr(inner_list(T))
}

fun list() => list(T) with T {
  let v = 0 as u64
  let inner = inner_list.new(0, v as ptr(T), 0)
  list.new(alloc(inner))
}

fun add(list : list(T), item : T) with T {
  let len = list.len
  print("len: "); print(len); println()
  if list.capacity <= list.len {
    let next_capacity = {
      if list.capacity == 0 { 1 }
      else { list.capacity * 2 }
    }
    let new_data = malloc(next_capacity * sizeof(T))
    memcpy(new_data, list.data as ptr(u8), list.capacity * sizeof(T))
    if (list.data as u64) != 0 { free(list.data as ptr(u8)) }
    list.data = new_data as ptr(T)
    list.capacity = list.capacity * 2
  }
  list.data[list.len] = item
  list.len = list.len + 1
}

fun Index(list : list(T), i : Int) => T with T, Int {
  let i = i as u64
  if i >= list.len {
    panic("list access out of bounds")
  }
  list.data[i]
}

fun println(list : list(T)) with T {
  print("[")
  for x in range(0, list.len as i64) {
    print(list[x]) ; print(", ")
  }
  print("]")
  println()
}

let nums : list(i64) = list()

for x in range(0, 10) {
  print(x) ; println()
  //nums.add(x)
}

//println(nums)

// let strings = list()
// strings.add("hello")
