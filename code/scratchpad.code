
// struct rc_heap {
//   count : i64
//   rc_data : u8
// }

// struct rc[T] {
//   p : ptr(rc_heap)
// }

// fun Deref(p : rc[T]) {
//   (&p.rc_data)
// }

// struct array_heap {
//   length : i64
//   array_data : u8
// }

// struct array[T] {
//   p : rc(array_heap)
// }

// fun Index[T](a : array[T], i : i64) {
//   // should have bounds checks but whatever
//   let p = &a.p.array_data
//   p[i]
// }

// let a = array(i64).new()
// a.add(5)
// a.add(5)
// a.add(5)


// struct counted {
//   count : i64
// }

// struct resource {
//   count : i64
// }

// struct rc {
//   count : i64
//   data : u8
// }

// fun rc_drop(p : ptr(rc)) {
//   rc.count = rc.count - 1
//   if rc.count <= 0 {
//     free(p)
//   }
// }

// fun to_ptr(p : ptr(rc)) {
//   &rc.data
// }

// fun implement_managed(t : ptr(expr)) {
//   build_module(#{
//     fun heap(v : $t) {
//       let bytes = sizeof($t)
//       print("Resource allocated"); println()
//       let p = malloc(bytes as u32) as ptr($t)
//       *p = v
//       p
//     }

//     fun Drop(p : ptr($t)) {
//       p.count = p.count - 1
//       print("Drop called"); println()
//       if p.count <= 0 {
//         print("Resource released"); println()
//         free(p as ptr(u8))
//       }
//     }

//     fun Clone(p : ptr($t)) {
//       print("Clone called"); println()
//       p.count = p.count + 1
//       p
//     }
//   })
// }

// implement_managed(#counted)

// build_module(#{
//   fun bloo() {
//     let c = counted.new(1).heap()

//     fun blah(c : ptr(counted)) {
//       let c2 = c.Clone()
//       if c2.count > 0 {
//         let c3 = c2.Clone()
//         (c3)
//         c3.Drop()
//       }
//       c2.Drop()
//     }

//     blah(c)
//     let r = c
//     c.Drop()
//     r
//   }

//   let c = bloo()
//   c.Drop()

//   print("final count: "); print(c.count); println()
// })

()