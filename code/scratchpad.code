
struct rc_inner {
  count : i64
  rc_data : u8
}

fun declare_rc(name : ptr(expr), inner_type : ptr(expr)) {
  build_module(#{
    struct $name {
      ptr : ptr(rc_inner)
    }

    fun deref(rc : $name) {
      &rc.ptr.rc_data as ptr($inner_type)
    }
  })
}

struct array_inner {
  length : i64
  array_data : u8
}

fun declare_array(element_type : ptr(expr)) {
  let array_type_name = #$("array_" + element_type.to_string())
  declare_rc(array_type_name, #array_inner)

  build_module(#{

    fun inner(a : $array_type_name) {
      &a.ptr.rc_data as ptr(array_inner)
    }

    fun len(a : $array_type_name) {
      a.inner().length
    }

    fun index_address(a : $array_type_name, i : i64) {
      let p = &a.ptr.rc_data as ptr(array_inner)
      let p = &p.array_data as ptr($element_type)
      &p[i]
    }

    fun index(a : $array_type_name, i : i64) {
      *a.index_address(i)
    }

    fun $array_type_name(values : array($element_type)) {
      let length = {
        let s = &values as ptr(string)
        s.length
      }
      // This is verbose, because I don't support unsigned multiplication yet
      let element_bytes = ((sizeof($element_type) as i64) * (length as i64)) as u64
      let total_bytes = {
        // This is a hack to find the offset to the first element
        let dummy = $array_type_name.new(0 as u64 as ptr(rc_inner))
        let offset = dummy.index_address(0) as u64
        offset + element_bytes
      }
      // I can't initialise the array pointer without knowing the name of the
      // internal rc type that was generated to hold the array, which I don't
      // know
      let array = *(&malloc(total_bytes) as ptr($array_type_name))
      array.inner().length = length
      let src = &values[0] as ptr(u8)
      memcpy(array.index_address(0) as ptr(u8), src, element_bytes)
      array
    }
  })
}

declare_array(#i64)

declare_array(#string)

build_module(#{
  //let a = array_i64([0, 1, 2, 20, 534, 3, 4])
  let a = array_string(["hello", "world"])
  let i = 0;
  while i < a.len() {
    print("a: "); print(a.index(i)); println()
    i = i + 1
  }
})

// struct rc_heap {
//   count : i64
//   rc_data : u8
// }

// struct rc(T) {
//   p : ptr(rc_heap)
// }

// fun Deref(p : rc[T]) {
//   (&p.rc_data)
// }

// struct array_heap {
//   length : i64
//   array_data : u8
// }

// struct array[T] {
//   p : rc(array_heap)
// }

// fun Index[T](a : array[T], i : i64) {
//   // should have bounds checks but whatever
//   let p = &a.p.array_data
//   p[i]
// }

// let a = array(i64).new()
// a.add(5)
// a.add(5)
// a.add(5)


// struct counted {
//   count : i64
// }

// struct resource {
//   count : i64
// }

// struct rc {
//   count : i64
//   data : u8
// }

// fun rc_drop(p : ptr(rc)) {
//   rc.count = rc.count - 1
//   if rc.count <= 0 {
//     free(p)
//   }
// }

// fun to_ptr(p : ptr(rc)) {
//   &rc.data
// }

// fun implement_managed(t : ptr(expr)) {
//   build_module(#{
//     fun heap(v : $t) {
//       let bytes = sizeof($t)
//       print("Resource allocated"); println()
//       let p = malloc(bytes as u32) as ptr($t)
//       *p = v
//       p
//     }

//     fun Drop(p : ptr($t)) {
//       p.count = p.count - 1
//       print("Drop called"); println()
//       if p.count <= 0 {
//         print("Resource released"); println()
//         free(p as ptr(u8))
//       }
//     }

//     fun Clone(p : ptr($t)) {
//       print("Clone called"); println()
//       p.count = p.count + 1
//       p
//     }
//   })
// }

// implement_managed(#counted)

// build_module(#{
//   fun bloo() {
//     let c = counted.new(1).heap()

//     fun blah(c : ptr(counted)) {
//       let c2 = c.Clone()
//       if c2.count > 0 {
//         let c3 = c2.Clone()
//         (c3)
//         c3.Drop()
//       }
//       c2.Drop()
//     }

//     blah(c)
//     let r = c
//     c.Drop()
//     r
//   }

//   let c = bloo()
//   c.Drop()

//   print("final count: "); print(c.count); println()
// })

()