  
let prelude = get_module("prelude").unwrap()
let sdl2 = load_module("sdl2", [prelude])
let sdl2_example = load_module("sdl2_example", [prelude, sdl2],)
let update = sdl2_example.get_function("update") as fun()
let terminate = sdl2_example.get_function("terminate") as fun()

struct timer_handle {
  _ : ptr(u8)
}

cbind start_timer : fun() => timer_handle
cbind drop_timer : fun(timer_handle)
cbind millis_elapsed : fun(timer_handle) => u64

struct watcher_handle {
  _ : ptr(u8)
}

cbind poll_watcher_event : fun(w: watcher_handle, path_out : ptr(option(string)))
cbind create_watcher : fun(millisecond_interval : u64) => watcher_handle
cbind drop_watcher : fun(w : watcher_handle)
cbind watch_file : fun(w : watcher_handle, path : ptr(string))

fun poll_watcher_event(w: watcher_handle) => option(string) {
  let out = none() ; poll_watcher_event(w, &out) ; out
}

fun watch_file(w : watcher_handle, path : string) {
  watch_file(w, &path)
}

let timer = start_timer()
let watcher = create_watcher(100)

watcher.watch_file("code/sdl2_example.code")

while true {
  // process any watcher events
  let start_time = timer.millis_elapsed()
  while true {
    let path = watcher.poll_watcher_event()
    if path.is_some {
      let path = path.val
      // handle event
      print(path); println(" changed!")
      terminate()
      unload_module(sdl2_example)
      sdl2_example = load_module("sdl2_example", [prelude, sdl2])
      update = sdl2_example.get_function("update") as fun()
      terminate = sdl2_example.get_function("terminate") as fun()
    }
    else { break }
  }
  // call the update function
  update()
  // sleep for the rest of the frame
  let end_time = timer.millis_elapsed()
  let elapsed = (end_time - start_time) as i64
  let sleep_time = max(16 - elapsed, 0)
  thread_sleep(sleep_time as u64)
}
