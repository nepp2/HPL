
cbind malloc : fun(size: u64) => ptr(u8)
cbind free : fun(ptr: ptr(u8))
cbind memcpy : fun(dest : ptr(u8), src : ptr(u8), length : u64) => ptr(u8)

struct range {
  start : i64
  limit : i64
}

struct string {
  data : ptr(u8)
  length : u64
}

fun +(a : string, b : string) {
 let length = a.length + b.length
 let data = malloc(length)
 memcpy(data, a.data, a.length)
 memcpy(&data[a.length as i64], b.data, b.length)
 string.new(data, length)
}

struct lib_handle {
  handle : u64
}

cbind load_library : fun(name : ptr(string)) => lib_handle

cbind load_symbol : fun(handle : lib_handle, name : ptr(string)) => ptr(u8)

cbind print_string : fun(s : ptr(string)) // ptr due to ABI issue
cbind print_expr : fun(e : ptr(expr))
cbind print_i64 : fun(v : i64)
cbind print_u64 : fun(v : u64)
cbind print_f64 : fun(v : f64)
cbind print_bool : fun(v : bool)

fun print(s : string) { print_string(&s) }
fun print(v : i64) { print_i64(v) }
fun print(v : u64) { print_u64(v) }
fun print(v : f64) { print_f64(v) }
fun print(v : bool) { print_bool(v) }
fun print(e : ptr(expr)) { print_expr(e) }
fun println() { print("\n") }

cbind thread_sleep : fun(millis : u64)

cbind compiler : ptr(u8)

// cbind prelude : ptr(u8)

cbind load_quote : fun(compiler : ptr(u8), name : ptr(string)) => ptr(expr)

fun max(a : i64, b : i64) {
  if a > b { a } else { b }
}

struct text_marker {
  line : u64
  col : u64
}

struct text_location {
  start : text_marker
  end: text_marker
}

union expr_data {
  list : expr_list
  symbol : string
  literal_string : string
  literal_float : f64
  literal_int : i64
  literal_bool : bool
}

print("Hello Andy"); println()


union expr_list {
  s : string
  array : expr_array
}

static list_tag : u64 = 0
static symbol_tag : u64 = 1
static literal_string_tag : u64 = 2
static literal_float_tag : u64 = 3
static literal_int_tag : u64 = 4
static literal_bool_tag : u64 = 5
static literal_unit_tag : u64 = 6

fun sym(s : string, loc : text_location) {
  let data = expr_data.new(symbol: s)
  let c = expr_content.new(symbol_tag, data)
  expr.new(loc, c)
}

fun sym(i : i64, loc : text_location) {
  let data = expr_data.new(literal_int: i)
  let c = expr_content.new(literal_int_tag, data)
  expr.new(loc, c)
}

// This style of tagged union is not really correct! It happens to work here
// because a u64 tag never triggers padding, but it will break if I change the
// tag to u8. To use a u8 tag I'd need to create a struct for each variant with
// the tag on each, and then a union of those structs. This can result in a
// more compact representation, but it's also a lot more boilerplate.
struct expr_content {
  tag : u64
  data : expr_data
}

struct expr_array {
  data : ptr(expr)
  length : u64
}

struct expr {
  loc : text_location
  content : expr_content
}

struct module_handle {
  id : u64
}

cbind expr_to_string : fun(out : ptr(string), e : ptr(expr))

fun to_string(e : ptr(expr)) {
  let out = string.new(0 as u64 as ptr(u8), 0 as u64)
  expr_to_string(&out, e)
  out
}

cbind template_quote : fun(e : ptr(expr), args : ptr(array(ptr(expr)))) => ptr(expr)

fun template_quote(e : ptr(expr), args : array(ptr(expr))) {
  template_quote(e, &args)
}

cbind build_module : fun(compiler : ptr(u8), expr : ptr(expr)) => module_handle

fun build_module(expr : ptr(expr)) {
  build_module(compiler, expr)
}

cbind get_function :
  fun(compiler : ptr(u8), module : module_handle, name : ptr(string)) => ptr(u8)

fun get_function(module : module_handle, name : string) {
  get_function(compiler, module, &name)
}

// ----------------- DEFINE RC AND ARRAY STUFF -------------------

// struct rc_inner {
//   count : i64
//   rc_data : u8
// }

// fun declare_rc(name : ptr(expr), inner_type : ptr(expr)) {
//   build_module(#{
//     struct $name {
//       ptr : ptr(rc_inner)
//     }

//     fun deref(rc : $name) {
//       &rc.ptr.rc_data as ptr($inner_type)
//     }

//     fun Drop(rc : ptr($name)) {
//       let inner = rc.ptr
//       inner.count = inner.count - 1
//       if inner.count <= 0 {
//         free(rc.ptr as ptr(u8))
//       }
//     }

//     fun Clone(rc : ptr($name)) {
//       rc.ptr.count = rc.ptr.count + 1
//       *rc
//     }
//   })
// }

// struct array_inner {
//   length : i64
//   array_data : u8
// }

// fun declare_array(element_type : ptr(expr)) {
//   let array_type_name = #$("array_" + element_type.to_string())
//   declare_rc(array_type_name, #array_inner)

//   build_module(#{

//     fun inner(a : $array_type_name) {
//       &a.ptr.rc_data as ptr(array_inner)
//     }

//     fun len(a : $array_type_name) {
//       a.inner().length
//     }

//     fun index_address(a : $array_type_name, i : i64) {
//       let p = &a.ptr.rc_data as ptr(array_inner)
//       let p = &p.array_data as ptr($element_type)
//       &p[i]
//     }

//     fun index(a : $array_type_name, i : i64) {
//       *a.index_address(i)
//     }

//     fun $array_type_name(values : array($element_type)) {
//       let length = {
//         let s = &values as ptr(string)
//         s.length
//       }
//       // This is verbose, because I don't support unsigned multiplication yet
//       let element_bytes = ((sizeof($element_type) as i64) * (length as i64)) as u64
//       let total_bytes = {
//         // This is a hack to find the offset to the first element
//         let dummy = $array_type_name.new(0 as u64 as ptr(rc_inner))
//         let offset = dummy.index_address(0) as u64
//         offset + element_bytes
//       }
//       // I can't initialise the array pointer without knowing the name of the
//       // internal rc type that was generated to hold the array, which I don't
//       // know
//       let array = *(&malloc(total_bytes) as ptr($array_type_name))
//       array.ptr.count = 0
//       array.inner().length = length
//       let src = &values[0] as ptr(u8)
//       memcpy(array.index_address(0) as ptr(u8), src, element_bytes)
//       array
//     }
//   })
// }

// declare_array(#i64)

// declare_array(#string)

()
